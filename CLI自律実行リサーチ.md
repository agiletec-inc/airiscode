# CLI 自律実行リサーチメモ

## 1. Claude Code
- **自律挙動**: 既存コードの文脈を丁寧に読み、提案を生成するが、明示的に指示しない限り勝手に shell を叩かない設計。ユーザーが「手順を踏んで」と促すと、差分検証 → ファイル編集 → テスト の順で細かく報告。
- **観察された特徴**
  - 大規模リポでは処理が重くなるため、対象ディレクトリを絞る指示が必須。
  - 差分説明やリファクタ理由などの自然言語生成が強く、レビューコメント作成に向く。
- **airiscode での活用ポイント**
  - “説明フェーズ”専用アダプターとして使い、Shell Guard には読み取り専用権限のみ付与。
  - 生成した根拠説明を MindBase に保存し、後段の Codex/Gemini へコンテキスト共有。

## 2. Codex CLI
- **自律挙動**: CLI 経由で `edit`, `run`, `test` など一連の操作を素直に実行。Approve モードや sandbox 設定を細かく制御でき、無断で危険操作を行いづらい。
- **観察された特徴**
  - Shell コマンド提案ごとに承認プロンプトを出すモードがデフォルト。
  - プロンプトベースで patch を作り、`git diff` を都度表示する。
- **airiscode での活用ポイント**
  - “実行フェーズ”実体としてラップし、Approvals/Trust の状態に応じて `auto-approve` フラグを切り替える。
  - Shell Guard によるコマンド審査 → Codex adapter → Runner というパイプラインを構築。

## 3. Gemini CLI
- **自律挙動**: 巨大なコンテキストを読み込んで判断し、ユーザーに確認を求めずに進む設定が存在。特に「ファイルを読み→理解→提案→実行」の流れで yes/no を待たず進める挙動が報告されている。
- **観察された特徴**
  - プロジェクト構造を俯瞰するまで実行を遅らせる傾向があり、依存解析や TODO 抽出に向いている。
  - API レート制限・安定性はまだ揺らぎがあるため、失敗時のフォールバック必須。
- **airiscode での活用ポイント**
  - “理解フェーズ + 自律プランナー”として、repo map を生成 → Codex への実行計画 JSON を作成。
  - Auto-Advance モード時のみ Gemini に「承認待ちスキップ」を許可し、それ以外は確認プロンプトを挟む。

## 4. 仕様への落とし込みヒント
1. **フェーズ制御**: Super Agent が `phase=understand/explain/execute` を定義し、それぞれのアダプターへ権限付きでジョブを送る。  
2. **自律実行スイッチ**: `--auto-advance`（内部的には approvals=never && trust>=sandboxed）でのみ Gemini の自律挙動を有効にする。  
3. **監査ログ**: 自律実行で走ったコマンドは `MindBase.auto_actions` に記録し、CLI 側で即時表示。  
4. **フォールバック**: Gemini adapter が失敗したら、Claude Code で簡易要約 → Codex で実装という通常モードに切り替える。  
5. **Shell Guard 連携**: 各 CLI が提案するコマンドは `packages/sandbox` 経由で審査し、危険判定は CLI 側にもフィードバックしてプロンプトを修正させる。

これらの観察事項を `CLI統合仕様.md` の各セクションに反映し、今後の実装でフェーズ分割と自律制御ロジックを組み込む。
